# 3 堆内存管理

## 3.1 简介

### 3.1.1 前提条件

作为一名合格的 C 程序员是使用 FreeRTOS 的前提条件，因此本章假定读者熟悉以下概念：

- 构建 C 项目时不同的编译和链接阶段。
- 栈和堆在哪里。
- 标准 C 库的 `malloc()` 和 `free()` 函数。
Being a competent C programmer is a prerequisite for using FreeRTOS, so
this chapter assumes the reader is familiar with concepts such as:

### 3.1.2 范围

本章包括：

- FreeRTOS 何时分配内存。
- FreeRTOS 提供的五种示例内存分配方案。
- 选用哪种内存分配方案。

### 3.1.3 动态内存分配和静态内存分配的切换

接下来的章节会介绍诸如任务、队列、信号量和事件组之类的内核对象。保存这些对象需要的 RAM 应该能够在编译期静态分配，或在运行时动态分配。动态分配会降低设计和规划难度，简化 API，并且减小 RAM 占用空间。静态分配更明确，无需处理内存分配失败，并且消除了堆碎片的风险（堆有足够的空闲内存，但不在一个可用的连续块中）。

使用静态分配的内存创建内核对象的 FreeRTOS API 函数仅在 FreeRTOSConfig.h 中将`configSUPPORT_STATIC_ALLOCATION` 设置为 1 时可用。使用动态分配的内存创建内核对象的 FreeRTOS API 函数仅在 FreeRTOSConfig.h 中将 `configSUPPORT_DYNAMIC_ALLOCATION` 设置为 1 或不定义时可用。可以同时将两个变量都设置为 1。

关于 `configSUPPORT_STATIC_ALLOCATION` 的更多信息可参阅 3.4 使用静态内存分配。

### 3.1.4 使用动态内存分配

动态内存分配时一个 C 编程概念，不是 FreeRTOS 或多任务处理特有的概念。之所以与 FreeRTOS 有关，是因为可以选择使用动态分配内存来创建内核对象，并且标准 C 库的 `malloc()` 和 `free()` 函数可能会因为以下原因不使用：

- 它们在小型嵌入式系统中并不总是可用。
- 它们的实现相对会比较大，占用珍贵的代码空间。
- 它们很少是线程安全的。
- 它们不是确定性的；执行函数所需的时间将因调用而异。
- 它们会有碎片化问题（堆有足够的空闲内存，但不在一个可用的连续块中）。
- 它们会使链接器的配置更复杂。
- 它们可能是难以 debug 错误的根源，如果允许堆内存增长到其他变量使用的内存中。

### 3.1.5 动态分配内存的选项

FreeRTOS 的早期版本使用内存池分配方案，在编译期预分配不同大小的内存块池，然后由内存分配函数返回。尽管块分配在实时系统中很常见，但是 FreeRTOS 还是去掉了它，因为其在非常小的嵌入式系统上对 RAM 的使用效率不高，导致了很多支持请求。

FreeRTOS 目前将内存分配看作是适配层（而不是核心代码库）的一部分。因为不同的嵌入式系统有不同的动态内存分配和事件要求，故单一的动态内存分配算法永远只能适用于一部分应用程序。因此，从核心代码库中移除动态内存分配使得应用程序作者可以在适配的时候使用他们自己特有的实现。

在 FreeRTOS 中，申请内存使用 `pvPortMalloc()` 而不是 `malloc()`。类似地，释放内存使用 `vPortFree()` 而不是 `free()`。`pvPortMalloc()` 和标准 C 库的 `malloc()` 函数有相同的函数原型，`vPortFree()` 和 `free()` 函数有相同的函数原型。

`pvPortMalloc()` 和 `vPortFree()` 是公共函数，所以他们也可以被应用程序代码调用。

FreeRTOS 附带了五种 `pvPortMalloc()` 和 `vPortFree()` 示例实现方式，本章都会讲到。FreeRTOS 应用程序可以使用这些示例实现方式之一，或者使用他们自己提供的方式。

五种示例分别定义在 heap_1.c、heap_2.c、heap_3.c、heap_4.c 和 heap_5.c 源文件中，它们都位于 FreeRTOS/Source/portable/MemMang 目录。


## 3.2 示例内存分配方案

### 3.2.1 Heap_1

小型专用嵌入式系统通常在 FreeRTOS 调度器启动前只创建任务和其他内核对象。在这种情况下，内存只在应用程序开始执行任务实时任务前由内存（动态）分配，并且在应用程序的生命周期中保持被分配状态。这意味着所选的方案不必考虑更复杂的内存分配问题，如确定性和碎片化，而是可以优先考虑如代码大小和简洁等属性。

heap_1.c 实现了一个非常基础版本的 `pvPortMalloc()`，并且没有实现 `vPortFree()`。从来不删除任务和其他内存对象的应用程序可以考虑用 heap_1。一些禁止使用动态内存分配的商业关键和安全关键系统也可能使用 heap_1。关键系统通常会禁止动态内存分配，因为其存在与非确定性、内存碎片和分配失败相关的不确定性。

heap_1 中 `pvPortMalloc()` 的实现在每次被调用时，将一个被称为 FreeRTOS 堆的简易 `uint8_t` 数组简单划分成更小的块。FreeRTOSConfig.h 中 `configTOTAL_HEAP_SIZE` 常量用来设置这个数组的字节数。将堆按照静态分配内存来实现使得 FreeRTOS 看起来消耗了大量内存，因为堆成为了 FreeRTOS 数据的一部分。

每个动态分配的任务会导致 `pvPortMalloc()` 被调用两次。第一次调用分配了一个任务控制块（TCB），第二次分配了任务的栈空间。图 3.1 演示了 heap_1 在任务创建时如何划分简易数组。

图 3.1 提到的内容：

- **A** 代表创建任务前的数组，整个数组都是可用的。

- **B** 代表创建了一个任务之后的数组。

- **C** 代表创建了三个任务之后的数组。


<a name="fig3.1" title="图 3.1 每次创建任务时，从 heap_1 数组分配 RAM"></a>

* * *
![](media/image05.png)   
***图 3.1*** *每次创建任务时，从 heap_1 数组分配 RAM*
* * *


### 3.2.2 Heap_2

heap_2 被拥有增强功能的 heap_4 取代了。FreeRTOS 发行版中保留 heap_2 是为了向后兼容，不建议在新设计中使用。

heap_2.c 也是通过划分 `configTOTAL_HEAP_SIZE` 常量定义的数组来实现。它使用最佳适应算法（best-fit）分配内存，并且不像 heap_1，它实现了 `vPortFree()`。同样地，将堆按照静态分配内存来实现使得 FreeRTOS 看起来消耗了大量内存，因为堆成为了 FreeRTOS 数据的一部分。

最佳适应算法（best-fit）确保 `pvPortMalloc()` 使用的空闲内存块在大小上是最接近申请字节数的。例如，以下场景中：

- 堆包含分别是 5 字节、25 字节和 100 字节的三块空闲内存。
- `pvPortMalloc()` 申请 20 字节的内存。

满足申请字节数的最小空闲内存块是 25 字节的块，因此 `pvPortMalloc()` 在返回一个20 字节块的指针钱，会将 25 字节的块分成一个 20 字节的和一个 5 字节的块[^2]。被划分出的 5 字节的块在将来 `pvPortMalloc()` 申请时依旧可用。

[^2]: 这是一个极简化的例子，因为 heap_2 会存储堆区域中块大小信息，因此两个划分出的块实际大小会小于 25 字节。

与 heap_4 不同，heap_2 不会将相邻的空闲块组合成一个单独的更大的块，因此相比 heap_4，它更容易受到碎片化的影响。然而，如果分配和释放的块总是相同大小的话，碎片化就不是问题。

<a name="fig3.2" title="图 3.2 每次创建或删除任务时，从 heap_2 数组分配或释放内存"></a>

* * *
![](media/image06.png)   
***图 3.2*** *每次创建或删除任务时，从 heap_2 数组分配或释放内存*
* * *

图 3.2 演示了当任务创建、删除以及再次被创建时，最佳适应算法如何工作。图 3.2 提到的内容如下：

- **A** 代表分配了三个任务之后的数组。在数组上方保留了一个很大的空闲块。
- **B** 代表删除其中一个任务之后的数组。在数组上方保留了一个很大的空闲块。还有两个更小的，之前用来保留已删除任务的 TCB 和栈空间的空闲块。
- **C** 代表分配了另一个任务之后的情况。使用 `xTaskCreate()` API 函数创建任务会调用两次 `pvPortMalloc()`，一次用来分配一个新的 TCB，另一次用来分配任务栈空间。本书 3.4 节会讲述 `xTaskCreate()`。
  
  每个 TCB 的大小都是相同的，因此最佳适应算法会复用之前保存被删除任务的 TCB 的 RAM，用于保存新建任务的 TCB。

  如果新建任务的栈空间大小和之前删除任务的栈空间大小相同，那么最佳适应算法会复用之前保存被删除任务栈空间的 RAM，用于保存新建任务的栈空间。

  数组上方较大的未分配块保持不变。

heap_2 不是确定性的，但是它比标准库实现的 `malloc()` 和 `free()` 更快。


### 3.2.3 Heap_3

heap_3.c 使用标准库的 `malloc()` 和 `free()` 函数，因此链接器配置定义了堆的大小，`configTOTAL_HEAP_SIZE` 常量没有用到。

heap_c 通过在执行期间临时挂起 FreeRTOS 调度器，来实现 `malloc()` 和 `free()` 的线程安全。第 8 章 资源管理涵盖了线程安全和调度器挂起。


### 3.2.4 Heap_4

类似 heap_1 和 heap_2，heap_4 通过将数组划分成更小的块来实现。正如前文所述，数组是通过 `configTOTAL_HEAP_SIZE` 定义大小的，静态分配的，这样会导致 FreeRTOS 看起来消耗了大量内存，因为堆成为了 FreeRTOS 数据的一部分。

heap_4 使用最先适应（first-fit）算法来分配内存。与 heap_2 不同，heap_4 将相邻的空闲内存块（合并）组合成一个单独的更大的块，最小化内存碎片化的风险。

最先适应（first-fit）算法确保 `pvPortMalloc()` 使用满足申请大小的第一个空闲内存块。例如，考虑如下场景：

- 堆包含三块空闲内存，他们在数组里的顺序是 5 字节、200 字节和 100 字节。
- `pvPortMalloc()` 申请 20 字节的内存。

第一个满足申请大小的空闲内存块是 200 字节的，因此 `pvPortMalloc()` 在返回 20 字节块的指针前，会将 200 字节的块分成一个 20 字节的块和一个 180 字节的块[^3]。划分出的 180 字节的块在之后 `pvPortMalloc()` 申请时依然可用。

[^3]: 这是一个极简化的例子，因为 heap_4 会存储堆区域中块大小信息，因此两个划分出的块实际大小会小于 200 字节。

heap_4 将相邻的空闲内存块（合并）组合，最大限度地降低碎片化的风险，使其适用于反复申请和释放不同大小内存块的应用程序。


<a name="fig3.3" title="图 3.3 从 heap_4 数组分配或释放内存"></a>

* * *
![](media/image07.png)   
***图 3.3*** *从 heap_4 数组分配或释放内存*
* * * 

图 3.3 演示了带有内存合并的 heap_4 最先适应算法的工作原理。图 3.3 提到的内容如下：

- **A** 代表创建了三个任务之后的数组。数组上方剩余一个较大的空闲块。

- **B** 代表删除其中一个任务之后的数组。数组上方较大的空闲块保持不变。此时另一个空闲的块之前是放被删除任务的 TCB 和 栈空间的。与 heap_2 不同，heap_4 将之前分别存放被删除任务的 TCB 和 栈空间的两个内存块合并成了一个更大的空闲块。

- **C** 代表创建了一个 FreeRTOS 队列之后的情况。本书 5.3 节会介绍动态分配队列的 API 函数  `xQueueCreate()`。该函数调用 `pvPortMalloc()` 申请队列用到的 RAM。由于 head_4 用的是最先适应算法，`pvPortMalloc()` 从第一个足够存放队列的空闲内存块分配 RAM，在图 3.3 中，是删除任务释放出的 RAM。队列并没有消耗掉这个空闲块中的所有内存，因此这个块被分为两个，并且没用到的部分在之后 `pvPortMalloc()` 申请时依然可用。

- **D** 代表应用程序代码直接调用 `pvPortMalloc()`，而不是调用 FreeRTOS API 函数之后的情况。用户申请的块非常小，可以放在第一个空闲块，即分配给队列和随后分配给 TCB 的内存之间的块。
  删除任务释放的内存现在已经被分成了三个独立的块；第一个块存放队列，第二个块存放用户申请的内存，第三个块保持空闲状态。

- **E** 代表删除队列之后的情况，删除队列会自动释放其申请的内存。现在在用户申请内存块的两边都有空闲内存。

- **F** 代表释放用户申请内存之后的情况。之前用户申请使用的内存已经和它两侧的空闲内存合并成了一个更大的空闲块。

heap_4 不是确定性的，但是它比大多数标准库实现的 `malloc()` 和 `free()` 要快。


### 3.2.5 Heap_5

heap_5 使用和 heap_4 相同的分配方案。与之不同的是，heap_4 仅限于从单个数组中分配内存，heap_5 可以将多个独立的内存空间组合到一个堆中。当运行 FreeRTOS 的系统提供的 RAM 在系统内存映射中没有显示为单个连续块（没有空间）时，heap_5 非常有用。


### 3.2.6 初始化 heap_5: vPortDefineHeapRegions() API 函数

`vPortDefineHeapRegions()`通过指定组成 heap_5 管理的堆的每个独立内存区域的起始地址和大小来初始化 heap_5。heap_5 是发行版提供的堆分配方案中唯一一个需要明确初始化的，并且在调用 `vPortDefineHeapRegions()` 之后才能使用。这意味着必须在调用 `vPortDefineHeapRegions()` 之后才能动态创建诸如任务、队列和信号量之类的内核对象。


<a name="list3.1" title="清单 3.1 vPortDefineHeapRegions() API 函数原型"></a>


```c
void vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions );
```
***清单 3.1*** *vPortDefineHeapRegions() API 函数原型*


`vPortDefineHeapRegions()` 将一组 `HeapRegion_t` 结构体作为它唯一的参数。每个结构体定义了将成为堆一部分的内存块的起始地址和大小，整个结构体数组定义了全部的堆空间。


<a name="list3.2" title="清单 3.2 HeapRegion_t 结构体"></a>


```c
typedef struct HeapRegion
{
    /* The start address of a block of memory that will be part of the heap.*/
    uint8_t *pucStartAddress;

    /* The size of the block of memory in bytes. */
    size_t xSizeInBytes;

} HeapRegion_t;
```
***清单 3.2*** *HeapRegion_t 结构体*


**参数:**

- `pxHeapRegions`

  指向 `HeapRegion_t` 结构体数组的指针。每个结构体定义了将成为堆一部分的内存块的起始地址和大小。

  数组中的 `HeapRegion_t` 结构体必须按照起始地址排列，描述内存区域最小起始地址的`HeapRegion_t` 结构体必须是数组中第一个，描述内存区域最大起始地址的结构体必须是数组中最后一个。
  
  将数组中最后一个 `HeapRegion_t` 结构体的 `pucStartAddress` 参数置为 `NULL`，代表数组结束。

举例来说，考虑图 3.4 中 **A** 假设的内存映射，其包含三个独立的内存块：RAM1、RAM2 和 RAM3。假设可执行代码放在只读内存中，这里没有显示。


<a name="fig3.4" title="图 3.4 内存映射"></a>

* * *
![](media/image08.png)   
***图 3.4*** *内存映射*
* * *

清单 3.3 展示了一个 `HeapRegion_t` 数组，它们共同描述了三个内存块的全部内容。


<a name="list3.3" title="清单 3.3 共同描述了三个内存块的全部内容的 HeapRegion_t 数组"></a>


```c
/* Define the start address and size of the three RAM regions. */
#define RAM1_START_ADDRESS ( ( uint8_t * ) 0x00010000 )
#define RAM1_SIZE ( 64 * 1024 )

#define RAM2_START_ADDRESS ( ( uint8_t * ) 0x00020000 )
#define RAM2_SIZE ( 32 * 1024 )

#define RAM3_START_ADDRESS ( ( uint8_t * ) 0x00030000 )
#define RAM3_SIZE ( 32 * 1024 )

/* Create an array of HeapRegion_t definitions, with an index for each
   of the three RAM regions, and terminate the array with a HeapRegion_t
   structure containing a NULL address. The HeapRegion_t structures must
   appear in start address order, with the structure that contains the
   lowest start address appearing first. */
const HeapRegion_t xHeapRegions[] =
{
    { RAM1_START_ADDRESS, RAM1_SIZE },
    { RAM2_START_ADDRESS, RAM2_SIZE },
    { RAM3_START_ADDRESS, RAM3_SIZE },
    { NULL,               0         } /* Marks the end of the array. */
};

int main( void )
{
    /* Initialize heap_5. */
    vPortDefineHeapRegions( xHeapRegions );

    /* Add application code here. */
}
```
***清单 3.3*** *共同描述了三个内存块的全部内容的 HeapRegion_t 数组*


尽管清单 3.3 正确描述了内存，但它并不是一个很好的例子，因为它将所有的内存都分配给了堆，没有留下任何可供其他变量使用的空闲内存。

构建步骤中的链接阶段给每个变量分配了内存地址。链接器可用的内存通常由链接器配置文件（如链接器脚本）描述。图 3.4 中 **B** 假设链接器脚本包含 RAM1 的信息，但不包含 RAM2 或 RAM3 的信息。结果就是，链接器会将变量放在 RAM1 中，留下 0x0001nnnn 之后的部分给 heap_5 用。0x0001nnnn 的实际值取决于应用程序中所有变量的总大小。链接器没有使用 RAM2 和 RAM3，这两部分都用于 heap_5。

清单 3.3 中展示的代码会导致将低于 0x0001nnnn 的地址分配给 heap_5，与用来保存变量的内存相重叠。如果您将 `xHeapRegions[]` 数组中第一个 `HeapRegion_t` 结构体的起始地址设置为 0x0001nnnn 而不是 0x00010000 的话，堆就不会与链接器使用的空间相重叠。然而这并不是推荐解决方案，因为：

- 起始地址并不容易定下来。
- 链接器使用的内存大小可能在将的构建时会变化，这导致 `HeapRegion_t` 结构体中的起始地址必须更新。
- 如果链接器使用的内存和 heap_5 使用的内存有重叠，构建工具无法发现，也就无法警告应用程序作者。

清单 3.4 展示了一种更方便、更好维护的示例。它声明了一个 `ucHeap` 数组，这个数组是一个普通变量，所以它成为链接器分配到 RAM1 的数据一部分。`xHeapRegions` 数组中第一个 `HeapRegion_t` 结构体描述了 `ucHeap` 的起始地址和大小，因此 `ucHeap` 成为 heap_5 管理的内存中的一部分。可以增加 `ucHeap` 的大小，直到链接器使用的内存消耗了所有 RAM1，如图 3.4 **C** 所示。


<a name="list3.4" title="Listing 3.4 An array of HeapRegion\_t structures that describe all of RAM2, all of RAM3, but only part of RAM1"></a>

```c
/* Define the start address and size of the two RAM regions not used by
   the linker. */
#define RAM2_START_ADDRESS ( ( uint8_t * ) 0x00020000 )
#define RAM2_SIZE ( 32 * 1024 )

#define RAM3_START_ADDRESS ( ( uint8_t * ) 0x00030000 )
#define RAM3_SIZE ( 32 * 1024 )

/* Declare an array that will be part of the heap used by heap_5. The
   array will be placed in RAM1 by the linker. */
#define RAM1_HEAP_SIZE ( 30 * 1024 )
static uint8_t ucHeap[ RAM1_HEAP_SIZE ];

/* Create an array of HeapRegion_t definitions. Whereas in Listing 3.3 the
   first entry described all of RAM1, so heap_5 will have used all of
   RAM1, this time the first entry only describes the ucHeap array, so
   heap_5 will only use the part of RAM1 that contains the ucHeap array.
   The HeapRegion_t structures must still appear in start address order,
   with the structure that contains the lowest start address appearing first. */

const HeapRegion_t xHeapRegions[] =
{
    { ucHeap,             RAM1_HEAP_SIZE },
    { RAM2_START_ADDRESS, RAM2_SIZE },
    { RAM3_START_ADDRESS, RAM3_SIZE },
    { NULL,               0 }           /* Marks the end of the array. */
};
```
***清单 3.4*** *描述所有 RAM2、所有 RAM 3、部分 RAM1 的 HeapRegion_t 结构体数组*


清单 3.4 示范的技术有以下优势：
- 没必要使用硬编码的起始地址。
- `HeapRegion_t` 结构体中用到的地址会自动被链接器填充，所以就算之后构建的时候，链接器用到的内存会增加，它也是正确的。
- 分配给 heap_5 的内存和链接器放入 RAM1 的数据不可能重叠。
- 如果 `ucHeap` 太大的话，应用程序无法链接。


## 3.3 堆相关的实用函数和宏

### 3.3.1 定义堆起始地址

heap_1、heap_2 和 heap_4 从 `configTOTAL_HEAP_SIZE` 定义的静态分配数组中分配内存。本节将这些分配方案统称为 heap_n。

有时堆需要被放在一个特定的内存地址。比如，分配给动态创建的任务的栈空间来源于堆，所以可能需要将堆放在高速内部内存，而不是低速外部内存（有关另一种在快速内存中分配任务栈空间的方法，请参阅下面的“将任务栈空间放在快速内存”小节）。`configAPPLICATION_ALLOCATED_HEAP` 这个编译期配置常量允许应用程序申声明数组，以代替 heap_n.c 源文件中的声明。在应用程序代码中声明数组使得作者能够指定其起始地址。

如果在 FreeRTOSConfig.h 中，`configAPPLICATION_ALLOCATED_HEAP` 被置为 1，则使用 FreeRTOS 的应用程序必须分配一个 `uint8_t` 类型的 `ucHeap` 数组，并且通过 `configTOTAL_HEAP_SIZE` 常量指定大小。

将一个变量放到指定内存地址的语法取决于使用的编译器，请参阅您使用的编译器文档。下面是两种编译器的实例：

- 清单 3.5 展示了 GCC 编译器声明数组并将数组放到 `.my_heap` 内存段的语法。
- 清单 3.6 展示了 IAR 编译器声明数组并将数组放到绝对内存地址 0x20000000 的语法。


<a name="list3.5" title="清单 3.5 使用 GCC 语法声明 heap_4 使用的数组，并将其放在 .my_heap 内存段"></a>


```c
uint8_t ucHeap[ configTOTAL_HEAP_SIZE ] __attribute__ ( ( section( ".my_heap" ) ) );
```
***清单 3.5*** *使用 GCC 语法声明 heap_4 使用的数组，并将其放在 .my_heap 内存段*



<a name="list3.6" title="清单 3.6 使用 IAR 语法声明 heap_4 使用的数组，并将数组放在绝对内存地址 0x20000000"></a>


```c
uint8_t ucHeap[ configTOTAL_HEAP_SIZE ] @ 0x20000000;
```
***清单 3.6*** *使用 IAR 语法声明 heap_4 使用的数组，并将数组放在绝对内存地址 0x20000000*



### 3.3.2 xPortGetFreeHeapSize() API 函数

`xPortGetFreeHeapSize()` API 函数返回了函数被调用时堆中空闲字节数。它不提供有关堆碎片的信息。

heap_3 中没有实现 `xPortGetFreeHeapSize()`。


<a name="list3.7" title="清单 3.7 xPortGetFreeHeapSize() API 函数原型"></a>


```c
size_t xPortGetFreeHeapSize( void );
```
***清单 3.7*** *xPortGetFreeHeapSize() API 函数原型*


**返回值:**

- `xPortGetFreeHeapSize()` 返回函数被调用时堆中没有被分配的字节数。


### 3.3.3 xPortGetMinimumEverFreeHeapSize() API 函数

xPortGetMinimumEverFreeHeapSize() API 函数返回自 FreeRTOS 应用程序开始执行以来堆中存在的最小未分配内存字节数。

`xPortGetMinimumEverFreeHeapSize()` 的返回值说明了应用程序离耗尽堆空间有多近。比如，如果 `xPortGetMinimumEverFreeHeapSize()` 返回 200，那么在应用程序开始执行后的某个时间，它距离堆空间不足不到200字节。


`xPortGetMinimumEverFreeHeapSize()` 也可以用来优化堆大小。比如，如果 `xPortGetMinimumEverFreeHeapSize()` 在执行已知堆使用率最高的代码时返回 2000，那 `configTOTAL_HEAP_SIZE` 可以最多减少 2000 字节。
`xPortGetMinimumEverFreeHeapSize()` can also be used to optimise the heap
size. For example, if `xPortGetMinimumEverFreeHeapSize()` returns 2000
after executing the code that you know has the highest heap usage,
`configTOTAL_HEAP_SIZE` can be reduced by up to 2000 bytes.

只有 heap_4 和 heap_5 实现了 `xPortGetMinimumEverFreeHeapSize()`。


<a name="list3.8" title="清单 3.8 xPortGetMinimumEverFreeHeapSize() API 函数原型"></a>


```c
size_t xPortGetMinimumEverFreeHeapSize( void );
```
***清单 3.8*** *xPortGetMinimumEverFreeHeapSize() API 函数原型*


**返回值:**

- `xPortGetMinimumEverFreeHeapSize()` 返回自 FreeRTOS 应用程序开始执行以来堆中存在的最小未分配内存字节数。


### 3.3.4 vPortGetHeapStats() API 函数

heap_4 和 heap_5 实现了 `vPortGetHeapStats()`，它通过将 `HeapStats_t` 结构体作为唯一的参数，完成了这个结构体的引用传递。

清单 3.9 展示了 `vPortGetHeapStats()` 函数原型。清单 3.10 展示了 `HeapStats_t` 结构体成员。


<a name="list3.9" title="清单 3.9 vPortGetHeapStatus() API 函数原型"></a>


```c
void vPortGetHeapStats( HeapStats_t *xHeapStats );
```
***清单 3.9*** *vPortGetHeapStatus() API 函数原型*



<a name="list3.10" title="清单 3.10 HeapStatus_t 结构体"></a>


```c
/* Prototype of the vPortGetHeapStats() function. */
void vPortGetHeapStats( HeapStats_t *xHeapStats );

/* Definition of the HeapStats_t structure. All sizes specified in bytes. */
typedef struct xHeapStats
{
    /* The total heap size currently available - this is the sum of all the
       free blocks, not the largest available block. */
    size_t xAvailableHeapSpaceInBytes;

    /* The size of the largest free block within the heap at the time
       vPortGetHeapStats() is called. */
    size_t xSizeOfLargestFreeBlockInBytes;

    /* The size of the smallest free block within the heap at the time
       vPortGetHeapStats() is called. */
    size_t xSizeOfSmallestFreeBlockInBytes;

    /* The number of free memory blocks within the heap at the time
       vPortGetHeapStats() is called. */
    size_t xNumberOfFreeBlocks;

    /* The minimum amount of total free memory (sum of all free blocks)
       there has been in the heap since the system booted. */
    size_t xMinimumEverFreeBytesRemaining;

    /* The number of calls to pvPortMalloc() that have returned a valid
       memory block. */
    size_t xNumberOfSuccessfulAllocations;

    /* The number of calls to vPortFree() that has successfully freed a
       block of memory. */
    size_t xNumberOfSuccessfulFrees;
} HeapStats_t;
```
***清单 3.10*** *HeapStatus_t结构体*


### 3.3.5 收集每个任务堆使用统计信息

本书 TBD-RB 小节讲到的 `vTaskGetInfo()` API 函数会将有关任务的信息填充到 `TaskStatus_t` 结构中。如果 FreeRTOSConfig.h 中的 `configTRACK_TASK_MEMORY_ALLOCATIONS` 编译时常量被置为 1，这个结构体会包含以下附加信息：

- 该任务调用 `pvPortMalloc()` 的次数。
- 该任务调用 `vPortFree()` 的次数。
- 该任务申请但还没有被任何任务释放的堆内存字节数（`vTaskGetInfo()` 被调用时）。
- 该任务自开始执行以来，在任何给定时间分配的最大堆内存量。


### 3.3.6 申请失败钩子函数

与标准库 `malloc()` 函数类似，`pvPortMalloc()` 如果无法分配请求的内存大小，则返回 `NULL`。申请失败的钩子（或回调）函数是一个应用程序提供的函数，它会在 `pvPortMalloc()` 返回 `NULL` 时被调用。您必须将 FreeRTOSConfig.h 中的 `configUSE_MALLOC_FAILED_HOOK` 设置为 1，才能进行回调。如果在使用动态内存分配创建内核对象的 FreeRTOS API 函数内部调用申请失败钩子函数，则不会创建该对象。

如果 FreeRTOSConfig.h 中的 `configUSE_MALLOC_FAILED_HOOK` 被置为 1，那么应用程序必须按照清单 3.11 提供的原型实现一个同名申请失败回调函数。应用程序可以用任何合适的方式实现这个函数。许多提供的 FreeRTOS 示例应用程序将申请失败视为致命错误，但这不是生产系统的最佳实践，生产系统应该从申请失败中优雅地恢复。


<a name="list3.11" title="清单 3.11 申请失败函数名及原型"></a>


```c
void vApplicationMallocFailedHook( void );
```
***清单 3.11*** *申请失败函数名及原型*


### 3.3.7 将任务栈放在快速内存中

因为任务的读写频率较高，所以应该把他们放在快速内存中，但您可能不希望将堆放在这个地方。FreeRTOS 通使用 `pvPortMallocStack()` 和 `vPortFreeStack()` 宏可选地使栈空间（通过 FreeRTOS API 代码分配的）具有自己的内存分配器。如果您希望栈空间来源于 `pvPortMalloc()` 管理的堆，那就让 `pvPortMallocStack()` 和 `vPortFreeStack()`保持未定义，因为默认情况下它们会分别调用 `pvPortMalloc()` 和 `vPortFree()`。不然的话，就把宏定义成调用应用程序提供的函数，如清单 3.12 所示。


<a name="list3.12" title="清单 3.12 将 pvPortMallocStack() 和 vPortFreeStack() 宏映射成用户程序定义的内存分配器"></a>


```c
/* Functions provided by the application writer than allocate and free 
   memory from a fast area of RAM. */

void *pvMallocFastMemory( size_t xWantedSize );

void vPortFreeFastMemory( void *pvBlockToFree );

/* Add the following to FreeRTOSConfig.h to map the pvPortMallocStack()
   and vPortFreeStack() macros to the functions that use fast memory. */

#define pvPortMallocStack( x ) pvMallocFastMemory( x )

#define vPortFreeStack( x ) vPortFreeFastMemory( x )
```
***清单 3.12*** *将 pvPortMallocStack() 和 vPortFreeStack() 宏映射成用户程序定义的内存分配器*


## 3.4 使用静态内存分配器

3.1.4 小节列举了动态内存分配的一些缺点。为了规避这些问题，静态内存分配允许开发者明确地创建每一个应用程序需要的内存块。该方法有以下优点：

- 所有需要的内存在编译期就是已知的。
- 所有内存都是确定的。

还有一些其他的优点，但是这些优点也带来了一些复杂性。最复杂的是增加了一些额外的应用函数来管理一些内核内存，第二复杂的是需要确保所有的静态内存都在合适的范围内声明。


### 3.4.1 启用静态内存分配器

通过将 FreeRTOSConfig.h 中的 `configSUPPORT_STATIC_ALLOCATION` 置 1 来启用静态内存分配器。当启用这个配置时，内核可以使用所有内核函数的 `static` 版本。这些函数分别是：

- `xTaskCreateStatic`
- `xEventGroupCreateStatic`
- `xEventGroupGetStaticBuffer`
- `xQueueGenericCreateStatic`
- `xQueueGenericGetStaticBuffers`
- `xQueueCreateMutexStatic`
  - *如果 `configUSE_MUTEXES` 为 1*
- `xQueueCreateCountingSemaphoreStatic`
  - *如果 `configUSE_COUNTING_SEMAPHORES` 为 1*
- `xStreamBufferGenericCreateStatic`
- `xStreamBufferGetStaticBuffers`
- `xTimerCreateStatic`
  - *如果 `configUSE_TIMERS` 为 1*
- `xTimerGetStaticBuffer`
  - *如果 `configUSE_TIMERS` 为 1*

这些函数会在本书相关章节中做进一步阐述。

### 3.4.2 静态内部内核内存

当启用静态内核分配器的时，空闲任务和定时器任务（如果启用的话）将会使用用户函数提供的静态内存。这些用户函数分别是：

- `vApplicationGetTimerTaskMemory`
  - *如果 `configUSE_TIMERS` 为 1*
- `vApplicationGetIdleTaskMemory`


#### 3.4.2.1 vApplicationGetTimerTaskMemory

如果 `configSUPPORT_STATIC_ALLOCATION` 和 `configUSE_TIMERS` 都开启的话，内核将会调用 `vApplicationGetTimerTaskMemory()`，以允许应用程序为计时器任务 TCB 和计时器任务栈空间创建并返回内存缓冲区。定时器任务内存函数的建议实现如清单 3.13 所示。


<a name="list3.13" title="清单 3.13 vApplicationGetTimerTaskMemory 函数的典型实现"></a>


```c
void vApplicationGetTimerTaskMemory( StaticTask_t **ppxTimerTaskTCBBuffer,
                                     StackType_t **ppxTimerTaskStackBuffer,
                                     uint32_t *pulTimerTaskStackSize )
{
  /* 如果提供给定时器任务的缓存实在函数内部声明的，那就必须声明成 static，否则它会被分配在函数栈空间里，这样的话当函数退出时，这些空间也就不存在了。 */
  static StaticTask_t xTimerTaskTCB;
  static StackType_t uxTimerTaskStack[ configMINIMAL_STACK_SIZE ];

  /* 传递一个 StaticTask_t 结构的指针，其中将存储计时器任务的状态。 */
  *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;

  /* Pass out the array that will be used as the Timer task's stack. */
  /* 传递定时器任务栈空间用到的数组 */
  *ppxTimerTaskStackBuffer = uxTimerTaskStack;

  /* 传递 *ppxTimerTaskStackBuffer 指向数组的栈大小。注意栈大小的是 StackType_t类型的 */
  *pulTimerTaskStackSize = sizeof(uxTimerTaskStack) / sizeof(*uxTimerTaskStack);
}
```
***清单 3.13*** *vApplicationGetTimerTaskMemory 函数的典型实现*


由于在包括 SMP 在内的任何系统中都只有一个计时器任务，因此计时器任务内存问题的有效解决方案是在 `vApplicationGetTimeTaskMemory()` 函数中分配静态缓冲区，并将缓冲区指针返回给内核。


#### 3.4.2.2 vApplicationGetIdleTaskMemory

空闲任务会在 CPU 核完成预定工作后执行。空闲任务会执行一些日常工作，并且如果启用了 `vTaskIdleHook()`，还可以触发用户的 `vTaskIdleHook()` 函数。在对称多处理系统（SMP）中，剩余的每个核心也都有非内部空闲任务，但这些任务会在内部被静态分配 `configMINIMUM_STACK_SIZE` 字节。

应用程序可以调用 `vApplicationGetIdleTaskMemory` 函数创建“主”空闲任务需要的缓存。清单 3.14 展示了使用静态局部变量创建所需缓存的 `vApplicationIdleTaskMemory()` 函数的典型实现。


<a name="list3.14" title="清单 3.14 vApplicationGetIdleTaskMemory 函数的典型实现"></a>

```c
void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer,
                                    StackType_t **ppxIdleTaskStackBuffer,
                                    uint32_t *pulIdleTaskStackSize )
{
  static StaticTask_t xIdleTaskTCB;
  static StackType_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ];

  *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
  *ppxIdleTaskStackBuffer = uxIdleTaskStack;
  *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
}
```
***清单 3.14*** *vApplicationGetIdleTaskMemory 函数的典型实现*

