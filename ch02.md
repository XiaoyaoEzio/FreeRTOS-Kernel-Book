# 2 FreeRTOS 内核发行

## 2.1 概述

为了帮助用户熟悉 FreeRTOS 内核文件和目录，本章会包含以下内容：

- 提供 FreeRTOS 目录结构的顶级视图。
- 描述任何特定 FreeRTOS 项目所需的源文件。
- 介绍示例应用程序。
- 提供有关如何创建新 FreeRTOS 项目的信息。

此处的描述仅涉及官方 FreeRTOS 的发行版。本书附带的示例采用了略有不同的组织方式。


## 2.2  了解 FreeRTOS 的发行

### 2.2.1 定义：FreeRTOS 移植

FreeRTOS 可以通过大约20种不同的编译器构建，并且可以运行在超过40种不同的处理器架构上，每种编译器和处理器的组合称为一种 FreeRTOS 移植。


### 2.2.2 构建 FreeRTOS

FreeRTOS 是一个库，它为原本单线程裸机应用程序提供多任务处理能力。

FreeRTOS 以源文件的形式提供给用户。一些源文件是所有移植通用的，有些则是某个移植特有的。当把这些源文件构建为您的项目的一部分时，就可以在您的应用程序中使用 FreeRTOS API。每个官方 FreeRTOS 移植都提供了一个可参考的示例应用程序。这些示例应用程序已经配置好了构建需要用的源文件和头文件。

每个示例应用程序都是“开箱即用”的，在构建时没有任何编译器错误或警告。如果构建工具的后续修改产生了新的错误或警告，请通过 FreeRTOS 支持社区（<https://forums.FreeRTOS.org>）向我们反馈。2.3 章节会介绍这些示例应用程序。


### 2.2.3 FreeRTOSConfig.h

FreeRTOSConfig.h 这个头文件中定义的常亮是用来配置内核的。请勿在您的源文件中直接引用 FreeRTOSConfig.h！您应该改为引用 FreeRTOS.h，它会在合适的时机引用 FreeRTOSConfig.h。

FreeRTOSConfig.h 用于为某个特定应用程序裁剪 FreeRTOS 内核。例如：FreeRTOSConfig.h 中包含的类似 configUSE_PREEMPTION 的常量用来定义 FreeRTOS 是使用抢占式调度还是非抢占式调度[^1]。

[^1]: 4.13 章节会介绍调度算法。

FreeRTOSConfig.h 会为某个特定应用程序裁剪 FreeRTOS，因此它应该被放在应用程序的一部分目录中，而不是 FreeRTOS 的源码目录。

主要的 FreeRTOS 发行版为每个 FreeRTOS 移植提供了一个实例应用程序，并且每个实例应用程序都有自己的  FreeRTOSConfig.h。建议基于您使用的 FreeRTOS 移植的实例应用程序提供的 FreeRTOSConfig.h 进行适配，而不是从头创建文件。

FreeRTOS 参考手册以及 <https://www.freertos.org/a00110.html> 都介绍了 FreeRTOSConfig.h 中出现的常量的含义。您没有必要在 FreeRTOSConfig.h 中引用所有的常量，如果省略的话，很多常量都有一个默认值。


### 2.2.4 官方发行版

各个 FreeRTOS 库（包括内核）可通过其自己的 Github 仓库以 zip 文件的形式获取。在生产代码中使用 FreeRTOS 时，可以很方便的获取单独的库。但最好是下载主要的 FreeRTOS 发行版来使用，因为它包含库和示例项目。

主要的发行版包含所有 FreeRTOS 库的源码、所有 FreeRTOS 内核移植以及所有 FreeRTOS 示例应用程序的项目文件。不要被这些文件的数量吓到！应用程序只需要很少一部分。

您可以通过 <https://github.com/FreeRTOS/FreeRTOS/releases/latest> 下载最新发行版的 zip 文件，也可以使用以下 Git 命令从主要发行版的 Github 上（包含从各自的 Git 仓库子模块中分离出的各个库）下载代码：

* * *
```
git clone https://github.com/FreeRTOS/FreeRTOS.git --recurse-submodules

git clone git@github.com:FreeRTOS/FreeRTOS.git --recurse-submodules
```
* * *

图 2.1 展示了 FreeRTOS 发行版的一二级目录：

<a name="fig2.1" title="图 2.1 FreeRTOS 发行版的目录结构"></a>

* * *
```
FreeRTOS
│ │
│ ├─Source  包含 FreeRTOS 内核的源码文件的目录
│ │
│ └─Demo    包含预配置和移植特有的 FreeRTOS 示例项目的目录
│
FreeRTOS-Plus
│
├─Source    包含一些 FreeRTOS 生态系统组件的源代码的目录
│
└─Demo      包含 FreeRTOS+ 生态系统组件的示例项目的目录
```
***图 2.1*** *FreeRTOS 发行版的目录结构*
* * *

发行版只包含一份 FreeRTOS 内核源码；所有的实例项目都使用 FreeRTOS/Source 目录下的内核源码，如果过目录结构有变动的话，可能会无法构建


### 2.2.5 所有移植共用的 FreeRTOS 源文件

tasks.c 和 list.c 实现了核心的 FreeRTOS 内核功能，并且这两个文件总是会被用到的。他们被直接放在图 2.2 展示的 FreeRTOS/Source 目录。这个目录还包括以下可选的源文件：

-  **queue.c**

   queue.c 提供队列和信号量服务，本书后面会讲到。queue.c 几乎也是必需的。

-  **timers.c**

   timers.c 提供软定时器功能，本书后面会讲到。只有当应用程序用到时才需要构建。

-  **event\_groups.c**

   event\_groups.c 提供事件组功能，本书后面会讲到。只有当应用程序用到时才需要构建。

-  **stream\_buffer.c**

   stream\_buffer.c 提供流缓存和消息缓存功能，本书后面会讲到。只有当应用程序用到时才需要构建。

-  **croutine.c**

   croutine.c 实现了 FreeRTOS 协程功能。只有当应用程序用到时才需要构建。协程只在非常小的微处理器上使用，目前已经很少用了。因此协程现在已经不维护了，而且新的设计上也不需要他们。本书不会讲解协程。

<a name="fig2.2" title="图 2.2 FreeRTOS 目录树中的核心源文件"></a>

* * *
```
FreeRTOS
│
└─Source
    │
    ├─tasks.c         FreeRTOS 源文件 - 必需
    ├─list.c          FreeRTOS 源文件 - 必需
    ├─queue.c         FreeRTOS 源文件 - 几乎必需
    ├─timers.c        FreeRTOS 源文件 - 可选
    ├─event_groups.c  FreeRTOS 源文件 – 可选
    ├─stream_buffer.c FreeRTOS 源文件 - 可选
    └─croutine.c      FreeRTOS 源文件 – 可选且不再维护
```
***图 2.2*** *FreeRTOS 目录树中的核心源文件*
* * *

可能会有人意识到，发行版 zip 文件中用到的这些文件名可能会导致命名空间冲突，因为许多项目会有同名文件。如果有必要的话，您可以自行修改这些文件名，但是发行版不会修改这些名字，因为这么做会破坏现有用户项目以及支持 FreeRTOS 的开发工具的兼容性。


### 2.2.6 某个移植特有的 FreeRTOS 源文件

FreeRTOS/Source/portable 目录包含某个移植特有的 FreeRTOS 源文件。portable 目录按照层次结构排列，先按照编译器排列，然后按照处理器架构排列。图 2.3 展示了这个结构。

为了使 FreeRTOS 能够在使用 '*compiler*' 编译的 '*architecture*' 架构的处理器上运行，您还必需构建位于 FreeRTOS/Source/portable/\[*compiler*\]/\[*architecture*\] 目录的文件。

正如第 3 章（堆内存管理）提到的，FreeRTOS 也将堆内存管理看作是适配层的一部分。如果`configSUPPORT_DYNAMIC_ALLOCATION`被置为0，则不会在您的项目中包含堆内存分配方法。

FreeRTOS 提供的示例堆分配方法位于 FreeRTOS/Source/portable/MemMang 目录。如果 FreeRTOS 被配置为使用动态内存管理，就必须在项目中包含该目录中的一个堆实现源文件，或使用您自己的实现。

> **！ 请勿在您的项目中包含多个示例堆分配实现。**


<a name="fig2.3" title="图 2.3 FreeRTOS 目录树中移植特有的源文件"></a>

* * *
```
FreeRTOS
│
└─Source
    │
    └─portable 包含所有移植特有源文件的目录
        │
        ├─MemMang 包含可选堆分配源文件的目录
        │
        ├─[compiler 1] 包含编译器 1 特有的移植文件的目录
        │   │
        │   ├─[architecture 1] 包含编译 1 架构 1 移植文件的目录
        │   ├─[architecture 2] 包含编译 1 架构 2 移植文件的目录
        │   └─[architecture 3] 包含编译 1 架构 3 移植文件的目录
        │
        └─[compiler 2] 包含编译器 2 特有的移植文件的目录
            │
            ├─[architecture 1] 包含编译 2 架构 1 移植文件的目录
            ├─[architecture 2] 包含编译 2 架构 2 移植文件的目录
            └─[etc.]
```
***图 2.3*** *FreeRTOS 目录树中移植特有的源文件*
* * *

### 2.2.7 引用路径

FreeRTOS 要求编译器的引用路径中包含三个目录，分别是：

1. FreeRTOS 内核核心头文件路径：FreeRTOS/Source/include。
2. FreeRTOS 移植用到的特定源文件路径：FreeRTOS/Source/portable/\[*compiler*\]/\[*architecture*\]。
3. FreeRTOSConfig.h 头文件所在的路径


### 2.2.8 头文件

使用 FreeRTOS API 的源文件必须引用 FreeRTOS.h，然后是包含 API 声明的头文件：task.h、queue.h、semphr.h、timers.h、event_groups.h、stream_buffer.h、message_buffer.h 或 croutine.h。请勿显式地引用其他 FreeRTOS 头文件，FreeRTOS.h 会自动引用 FreeRTOSConfig.h。


## 2.3 示例应用程序

每个 FreeRTOS 适配附带了至少一个示例应用程序，这些应用程序都是“开箱即用”的，在构建时没有任何编译器错误或警告。如果构建工具的后续修改产生了新的错误或警告，请通过 FreeRTOS 支持社区（<https://forums.FreeRTOS.org>）向我们反馈。

> **跨平台支持**：FreeRTOS 已经在 Windows、Linux 和 MacOS 上使用多种工具链（包括嵌入式和传统式）开发并测试过。然而，由于版本差异或遗漏的测试偶尔会出现构建错误。请通过 FreeRTOS 支持社区（<https://forums.FreeRTOS.org>）提醒我们任何错误。

示例应用程序有以下几个目的：

- 提供一个可工作且预配置的项目示例，其中包含正确的文件并设置正确的编译器选项。
- 允许以最少的设置或先验知识进行“开箱即用”的实验。
- 示范如何使用 FreeRTOS API。
- 作为每个实际应用程序的生成模板。
- 压力测试内核的实现。

每个示例项目都位于 FreeRTOS/Demo 目录下的一个特有子目录。子目录的名称说明了这个示例项目涉及的移植。

FreeRTOS.org 网站上有每个实例应用程序的介绍页。这个网站包含以下信息：

- 如何在 FreeRTOS 目录结构中查找这个示例的项目代码。
- 项目使用的硬件或模拟器。
- 如何配置硬件使之能运行示例。
- 如何构建这个示例。
- 示例的预期表现。

所有示例项目都创建了“常见演示任务”的一个子集，其实现位于 FreeRTOS/Demo/Common/Minimal 目录。常见演示任务用于演示如何使用 FreeRTOS API 和测试 FreeRTOS 内核移植，它们不实现任何特定的有用功能。

许多示例项目也可以用于创建一个简单的“blinky”风格的入门项目，该项目通常会创建两个 RTOS 任务和一个队列。

每个示例项目有一个 存放`main()`函数的 main.c 文件，该函数会在 FreeRTOS 内核启动前创建示例应用程序任务。有关该演示的特定信息，请参阅各个main.c文件中的注释。

<a name="fig2.4" title="图 2.4 示例程序目录结构"></a>

* * *
```
FreeRTOS
    │
    └─Demo          包含所有示例项目的目录
        │
        ├─[Demo x]  包含用于构建示例“x”的项目文件
        ├─[Demo y]  包含用于构建示例“y”的项目文件
        ├─[Demo z]  包含用于构建示例“z”的项目文件
        └─Common    包含用于构建所有示例应用程序都用到的文件
```
***图 2.4*** *示例程序目录结构*
* * *


## 2.4 创建一个 FreeRTOS 项目

### 2.4.1 改造一个提供示例项目

每个 FreeRTOS 移植都附带至少一个配置好的示例应用程序。建议通过改造其中一个来创建新项目，以确保新项目包含了正确的文件，安装了正确的中断处理器，并且设置了正确的编译器选项。

基于一个已存在的示例项目来创建新用户程序：

1. 打开提供的示例项目，并确保它可以按照预期构建和执行。
2. 去掉位于 Demo/Common 目录下，用来实现实例任务的源文件。
3. 删掉`main()`函数中调用除了`prvSetupHardware()`和`vTaskStartScheduler()`之外的所有函数，如列表 2.1 所示。
4. 检查项目依旧可以编译通过。

当您按照这些步骤执行完，您就创建了一个包含正确 FreeRTOS 源文件，但是没有定义任何功能的项目。


<a name="list2.1" title="列表 2.1 main() 函数的模板"></a>


```c
int main( void )
{
    /* Perform any hardware setup necessary. */
    prvSetupHardware();

    /* --- APPLICATION TASKS CAN BE CREATED HERE --- */

    /* Start the created tasks running. */
    vTaskStartScheduler();

    /* Execution will only reach here if there was insufficient heap to
       start the scheduler. */
    for( ;; );
    return 0;
}
```
***列表 2.1*** *main() 函数的模板*



### 2.4.2 从头创建一个新的项目

正如前文所述，建议基于一个已经存在的示例项目来创建新项目。如果这么做不可行的话，可以按照下面的步骤创建一个新项目：

1. 使用您选择的工具链创建一个不含任何 FreeRTOS 源文件的新项目。
2. 确保新项目可以正常编译、烧录到您的目标硬件上，且可以正常运行。
3. 当确定您的项目已经可以正常工作，将表 1 详细列出的 FreeRTOS 源文件加入到项目中。
4. 将为移植提供的示例项目使用的`FreeRTOSConfig.h`头文件复制到您新建项目的目录中。
5. 将以下目录添加到项目搜索本地头文件的路径中：
   - FreeRTOS/Source/include
   - FreeRTOS/Source/portable/\[*compiler*\]/\[*architecture*\] （\[*compiler*\] 和 \[*architecture*\] 对应您选择的移植）
   - 包含`FreeRTOSConfig.h`头文件的目录
6. 从相关的示例项目中复制编译器配置。
7. 安装所有可能需要的 FreeRTOS 中断处理器。您可以参考描述该移植的网页和该移植提供的示例项目。

<a name="tbl1" title="表 1 项目中需要包含的 FreeRTOS 源文件"></a>

* * *
| File                            | Location                     |
|---------------------------------|------------------------------|
| tasks.c                         | FreeRTOS/Source              |
| queue.c                         | FreeRTOS/Source              |
| list.c                          | FreeRTOS/Source              |
| timers.c                        | FreeRTOS/Source              |
| event\_groups.c                 | FreeRTOS/Source              |
| stream\_buffer.c                | FreeRTOS/Source              |
| 所有 C 和汇编文件                | FreeRTOS/Source/portable/\[compiler\]/\[architecture\] |
| heap\_n.c                       | FreeRTOS/Source/portable/MemMang, n 为 1 - 5 |

***表 1*** *项目中需要包含的 FreeRTOS 源文件*
* * *

**堆内存注意事项:**
 在您的项目中，如果`configSUPPORT_DYNAMIC_ALLOCATION`为 0，则不需要包含堆内存分配方法。否则需要您的项目需要包含一个堆内存分配方法，无论是 heap\_*n*.c 文件中的一个，还是您自己实现。详细信息请参阅第 3 章堆内存管理。


## 2.5 数据类型和编码风格指南

### 2.5.1 数据类型

每个 FreeRTOS 移植都有一个独有的 portmacro.h 头文件，该文件定义了两种移植特有的数据类型：`TickType_t`和`BaseType_t`。下表列出了宏或者typedef以及其实际类型：
Each port of FreeRTOS has a unique portmacro.h header file that contains
(amongst other things) definitions for two port-specific data types:
`TickType_t` and `BaseType_t`. The following list describes the macro or
typedef used and the actual type:

- `TickType_t`

  FreeRTOS 有一个称为 tick 中断的周期性中断。从 FreeRTOS 应用程序启动开始触发的 tick 中断的数量被称为 *tick 计数*。该参数用来度量时间。两次 tick 中断之间的时间被称为 *tick 时间片*。一段时间被视为由多个 tick 时间片组成。

  `TickType_t`是用于保存 tick 计数值和指定时间的数据类型。`TickType_t`可以是无符号 16-bit 类型，可以是无符号 32-bit 类型，也可以是无符号 64-bit 类型，取决于 FreeRTOSConfig.h 中`configTICK_TYPE_WIDTH_IN_BITS`的配置。该配置是架构相关的，FreeRTOS 移植也会检查这个配置是否有效。

  在 8-bit 和 16-bit 架构上使用 16-bit 类型可以极大地提升效率，但是会严重限制在 FreeRTOS API 调用中可以指定的最大阻塞时间。没道理在 32-bit 或 64-bit 架构上使用 16-bit 类型的`TickType_t`。

  之前使用的`configUSE_16_BIT_TICKS`已经被`configTICK_TYPE_WIDTH_IN_BITS`取代，以支持超过 32-bit 的 tick 计数。新设计应该使用`configTICK_TYPE_WIDTH_IN_BITS`而不是`configUSE_16_BIT_TICKS`。

   <a name="tbl2" title="表 2 TickType_t 数据类型和 configTICK_TYPE_WIDTH_IN_BITS 配置的关系"></a>

   * * *
   | configTICK_TYPE_WIDTH_IN_BITS | 8-bit 架构 | 16-bit 架构 | 32-bit 架构 | 64-bit 架构 |
   | --- | --- | --- | --- | --- |
   | TICK\_TYPE\_WIDTH\_16_BITS | uint16_t	| uint16_t	| uint16\_t	| N/A |
   | TICK\_TYPE\_WIDTH\_32_BITS | uint32\_t	| uint32\_t	| uint32\_t	| N/A |
   | TICK\_TYPE\_WIDTH\_64_BITS | N/A | N/A | uint64\_t | uint64\_t |

   ***表 2*** *TickType_t 数据类型和 configTICK_TYPE_WIDTH_IN_BITS 配置的关系*
   * * *

- `BaseType_t`

  `BaseType_t`总是被定义为架构效率最高的数据类型。一般地，在 64-bit 架构上它是 64-bit 的，在 32-bit 架构上它是 32-bit 的，在 16-bit 架构上它是 16-bit 的，在 8-bit 架构上它是 8-bit 的。该类型通常用于只接受非常有限值范围的返回类型，以及用于`pdTRUE`/`pdFALSE`类型的布尔值。


*FreeRTOS 用到的移植特定的数据类型列表*


### 2.5.2 变量命名

变量需要根据其类型增加前缀：`char`类型以‘c’开头，`int16_t`（short）类型以‘s’开头，`int32_t`（long）以‘l’开头，`BaseType_t`和其他非标准类型（结构体，任务处理函数，队列处理函数等等）以‘x’开头。

如果变量是无符号，前缀还需要加一个‘u’。如果变量是一个指针，前缀还需要加一个‘p’。例如：`uint8_t`类型的变量应该以‘uc’开头，char 指针（`char *`）类型的变量应该以‘pc’开头。


### 2.5.3 函数命名

函数以其返回值类型和所在文件名为前缀。例如：

- v**Task**PrioritySet() 定义在 **tasks**.c，并返回 *void* 类型。
- x**Queue**Receive() 定义在 **queue**.c，并返回 *BaseType_t* 类型。
- pv**Timer**GetTimerID() 定义在 **timers**.c，并返回 *void 指针* 类型。

文件作用域（private）函数应以‘prv’开头。


### 2.5.4 格式化

示例应用程序中的 tab 总是等于 4 个空格。内核不再使用 tab。


### 2.5.5 宏命名

大多数宏写成大写字母，并且以小写字母开头，表示宏定义的位置。表 3 提供了前缀列表。


<a name="tbl3" title="表 3 宏前缀说明"></a>

* * *
| 前缀                                    | 宏定义的位置                    |
|-----------------------------------------|--------------------------------|
| port （例如，`portMAX_DELAY`）           | `portable.h` 或 `portmacro.h`  |
| task （例如，`taskENTER_CRITICAL()`）    | `task.h`                       |
| pd （例如，`pdTRUE`）                    | `projdefs.h`                   |
| config （例如，`configUSE_PREEMPTION`）  | `FreeRTOSConfig.h`             |
| err （例如，`errQUEUE_FULL`）            | `projdefs.h`                   |

***表 3*** *宏前缀说明*
* * *

注意信号量 API 几乎全部写作是宏的形式，但遵循的是函数命名约定而不是宏命名约定。

表 4 中定义的宏会在整个 FreeRTOS 源码中使用。

<a name="tbl4" title="表 4 通用宏定义"></a>

* * *
| 宏           | 值    |
|--------------|-------|
| `pdTRUE`     | 1     |
| `pdFALSE`    | 0     |
| `pdPASS`     | 1     |
| `pdFAIL`     | 0     |

***表 4*** *通用宏定义*
* * *


### 2.5.6 过度类型转换的原理

FreeRTOS 源码会通过很多种编译器编译，很多编译器生成警告的方式时机各不相同。特别是不同的编译器希望以不同的方式使用强制转换。因此，FreeRTOS 源码包含的类型转换比通常保证的要多。
